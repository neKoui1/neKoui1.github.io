<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>哈夫曼编码和解码 | Koui</title><meta name="keywords" content="Algorithms"><meta name="author" content="Koui"><meta name="copyright" content="Koui"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="难得自己亲自写个作业">
<meta property="og:type" content="article">
<meta property="og:title" content="哈夫曼编码和解码">
<meta property="og:url" content="http://example.com/2022/05/09/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/index.html">
<meta property="og:site_name" content="Koui">
<meta property="og:description" content="难得自己亲自写个作业">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/47.jpg">
<meta property="article:published_time" content="2022-05-09T13:27:17.000Z">
<meta property="article:modified_time" content="2022-05-09T13:53:54.905Z">
<meta property="article:author" content="Koui">
<meta property="article:tag" content="Algorithms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/47.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/05/09/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '哈夫曼编码和解码',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-09 21:53:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/77609544?s=400&amp;u=cc9b64e551e42cfd19084c0046e145b2cbf0f342&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/47.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Koui</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">哈夫曼编码和解码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-09T13:27:17.000Z" title="发表于 2022-05-09 21:27:17">2022-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-09T13:53:54.905Z" title="更新于 2022-05-09 21:53:54">2022-05-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Data-Structure-and-Algorithms/">Data Structure and Algorithms</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Target &amp; Content</h1>
<p>利用哈夫曼编码进行通信可以大大提高信道利用率， 缩短信息传输时间，降低传输成本。但是，这要求在发送 端通过一个编码系统对待传数据预先编码，在接收端将传 来的数据进行译码（复原）。对于双工信道（即可以双向 传输信息的信道），每端都需要一个完整的编/译码系统。 试为这样的信息收发站写一个哈夫曼码的编/译码系统。</p>
<p>xiebulai,gaoci</p>
<h1>Requirement</h1>
<p>编写完整的系统，要求具有以下功能：</p>
<ol>
<li>初始化（Initialization）。从终端读入字符集大小n，以及n 个字符和n个权值，建立哈夫曼树，并将它存入文件 hfmTree中。</li>
<li>编码(Encoding)。利用已建好的哈夫曼树（如不在内存，则从文件hfmTree中读入），对文件ToBeTran中的正文进行编码，然后将结果存入文件CodeFile中。</li>
<li>译码(Decoding)。利用已建好的哈夫曼树将文件CodeFile 中的代码进行译码，结果存入文件TextFile中。</li>
<li>印代码文件（Print)。将文件CodeFile以紧凑格式显示在终 端上，每行50个代码。同时将此字符形式的编码文件写入文件CodePrin中。</li>
<li>印哈夫曼树(Tree printing)。将已在内存中的哈夫曼树以直 观的方式（树或凹入表形式）显示在终端上，同时将此字符形式的哈夫曼树写入文件TreePrint中。</li>
</ol>
<p>👴这周听课辣，首先👴得会个标准化输入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line">	input := <span class="string">&quot;Tom 12&quot;</span></span><br><span class="line">	fmt.Sscan(input, &amp;name, &amp;age)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name: %v\n&quot;</span>, name)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;age: %v\n&quot;</span>, age)</span><br><span class="line">	input = <span class="string">&quot;DDD : 100&quot;</span></span><br><span class="line">	fmt.Sscanf(input, <span class="string">&quot;%s : %d&quot;</span>, &amp;name, &amp;age)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name: %v\n&quot;</span>, name)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;age: %v\n&quot;</span>, age)</span><br><span class="line"></span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	na, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">   		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(na)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>Sscan</code>函数根据空格自动分辨输入的是啥</li>
<li><code>Sscanf</code>函数可以通过空格+指定符号的格式来分割变量的赋值</li>
<li>标准化输入字符串的重点：一直到输入换行符才结束（再打一遍</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Initialization</h1>
<p>写下<code>initilalization</code>函数，包括以下的功能：</p>
<ol>
<li>标准化输入</li>
<li>得到哈夫曼树</li>
<li>将数据写入<code>hfmTree</code>的文件中</li>
</ol>
<h2 id="标准化输入与得到权值">标准化输入与得到权值</h2>
<p>标准化输入上文已经给出了，想要得到权值可以使用map</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">weights := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">	weights[v]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> weights &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;weights[%c] = %v\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接range input 之后print weights发现不对劲</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Please input correct <span class="keyword">string</span> :</span><br><span class="line">djaowefhnrujsgv</span><br><span class="line">weights[o] = <span class="number">1</span></span><br><span class="line">weights[h] = <span class="number">1</span></span><br><span class="line">weights[n] = <span class="number">1</span></span><br><span class="line">weights[u] = <span class="number">1</span></span><br><span class="line">weights[s] = <span class="number">1</span></span><br><span class="line">] = <span class="number">1</span>ts[</span><br><span class="line">weights[d] = <span class="number">1</span></span><br><span class="line">weights[e] = <span class="number">1</span></span><br><span class="line">weights[r] = <span class="number">1</span></span><br><span class="line">weights[g] = <span class="number">1</span></span><br><span class="line">weights[v] = <span class="number">1</span></span><br><span class="line">] = <span class="number">1</span></span><br><span class="line">weights[j] = <span class="number">2</span></span><br><span class="line">weights[w] = <span class="number">1</span></span><br><span class="line">weights[f] = <span class="number">1</span></span><br><span class="line">weights[a] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>有俩玩意是<strong>打印不出来的</strong></p>
<p>排查半天发现标准化输入的string最后的两个符号属于<code>\r\n</code>，没有属于它们的图形化符号，所以会导致哈希表对应不上</p>
<p><strong>为啥会出现<code>/r/n</code>…</strong> 找半天也找不到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Initialization</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Please input correct string :&quot;</span>)</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	weights := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		<span class="keyword">if</span> v == <span class="string">&#x27;\r&#x27;</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		weights[v]++</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(input[:<span class="built_in">len</span>(input)<span class="number">-2</span>])</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(weights))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> weights &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;weights[%c] = %v\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Initialization()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>res:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Please input correct <span class="keyword">string</span> :</span><br><span class="line">aauib</span><br><span class="line">aauib</span><br><span class="line"><span class="number">4</span></span><br><span class="line">weights[u] = <span class="number">1</span></span><br><span class="line">weights[i] = <span class="number">1</span></span><br><span class="line">weights[b] = <span class="number">1</span></span><br><span class="line">weights[a] = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="通过权值建立Huffman-Tree">通过权值建立Huffman Tree</h2>
<p>很明显的需要一个升序的排序算法…</p>
<p>想到了之前学到的回调函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NodesSort</span><span class="params">()</span></span> &#123;</span><br><span class="line">	less := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Nodes[i].Weight &lt; Nodes[j].Weight</span><br><span class="line">	&#125;</span><br><span class="line">	sort.SliceStable(Nodes, less)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后哈夫曼树生成就是每次Nodes的前两个连接成一个新Node，一直到只剩两个结点，排序后就连上哈夫曼树的根</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHuffman</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(Nodes) != <span class="number">2</span> &#123;</span><br><span class="line">		newNode := Constructor(<span class="number">0</span>, Nodes[<span class="number">0</span>].Weight+Nodes[<span class="number">1</span>].Weight)</span><br><span class="line">		newNode.Left = &amp;Nodes[<span class="number">0</span>]</span><br><span class="line">		newNode.Right = &amp;Nodes[<span class="number">1</span>]</span><br><span class="line">		Nodes = <span class="built_in">append</span>(Nodes, newNode)</span><br><span class="line">		Nodes = Nodes[<span class="number">2</span>:]</span><br><span class="line">		NodesSort()</span><br><span class="line">	&#125;</span><br><span class="line">	NodesSort()</span><br><span class="line">	Tree.Root.Weight = Nodes[<span class="number">0</span>].Weight + Nodes[<span class="number">1</span>].Weight</span><br><span class="line">	Tree.Root.Left = &amp;Nodes[<span class="number">0</span>]</span><br><span class="line">	Tree.Root.Right = &amp;Nodes[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="保存二叉树及写入文件">保存二叉树及写入文件</h2>
<p>保存二叉树的方法用的是一条路走到底，检索到nil再返回；马上还要根据这个文件写出树来，fk</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> store = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Traverse</span><span class="params">(root *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		store = <span class="built_in">append</span>(store, <span class="string">&quot;nil&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val == <span class="number">0</span> &#123;</span><br><span class="line">		store = <span class="built_in">append</span>(store, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, root.Weight))</span><br><span class="line">		Traverse(root.Left)</span><br><span class="line">		Traverse(root.Right)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		store = <span class="built_in">append</span>(store, <span class="keyword">string</span>(root.Val))</span><br><span class="line">		Traverse(root.Left)</span><br><span class="line">		Traverse(root.Right)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是把string切片保存在<code>hfmTree.txt</code>文件中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SavehfmTree</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Create(<span class="string">&quot;hfmTree.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Create htfTree err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	write := bufio.NewWriter(file)</span><br><span class="line">	Traverse(Tree.Root)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> store &#123;</span><br><span class="line">		write.WriteString(v + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	write.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总览">总览</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val    <span class="keyword">byte</span></span><br><span class="line">	Weight <span class="keyword">int</span></span><br><span class="line">	Left   *Node</span><br><span class="line">	Right  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuffmanTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	Root *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(v <span class="keyword">byte</span>, w <span class="keyword">int</span>)</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Node&#123;</span><br><span class="line">		v, w, <span class="literal">nil</span>, <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Nodes []Node</span><br><span class="line"><span class="keyword">var</span> Tree = HuffmanTree&#123;Root: &amp;Node&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NodesSort</span><span class="params">()</span></span> &#123;</span><br><span class="line">	less := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Nodes[i].Weight &lt; Nodes[j].Weight</span><br><span class="line">	&#125;</span><br><span class="line">	sort.SliceStable(Nodes, less)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHuffman</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(Nodes) != <span class="number">2</span> &#123;</span><br><span class="line">		newNode := Constructor(<span class="number">0</span>, Nodes[<span class="number">0</span>].Weight+Nodes[<span class="number">1</span>].Weight)</span><br><span class="line">		newNode.Left = &amp;Nodes[<span class="number">0</span>]</span><br><span class="line">		newNode.Right = &amp;Nodes[<span class="number">1</span>]</span><br><span class="line">		Nodes = <span class="built_in">append</span>(Nodes, newNode)</span><br><span class="line">		Nodes = Nodes[<span class="number">2</span>:]</span><br><span class="line">		NodesSort()</span><br><span class="line">	&#125;</span><br><span class="line">	NodesSort()</span><br><span class="line">	Tree.Root.Weight = Nodes[<span class="number">0</span>].Weight + Nodes[<span class="number">1</span>].Weight</span><br><span class="line">	Tree.Root.Left = &amp;Nodes[<span class="number">0</span>]</span><br><span class="line">	Tree.Root.Right = &amp;Nodes[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> store = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Traverse</span><span class="params">(root *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		store = <span class="built_in">append</span>(store, <span class="string">&quot;nil&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val == <span class="number">0</span> &#123;</span><br><span class="line">		store = <span class="built_in">append</span>(store, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, root.Weight))</span><br><span class="line">		Traverse(root.Left)</span><br><span class="line">		Traverse(root.Right)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		store = <span class="built_in">append</span>(store, <span class="keyword">string</span>(root.Val))</span><br><span class="line">		Traverse(root.Left)</span><br><span class="line">		Traverse(root.Right)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SavehfmTree</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Create(<span class="string">&quot;hfmTree.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Create htfTree err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	write := bufio.NewWriter(file)</span><br><span class="line">	Traverse(Tree.Root)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> store &#123;</span><br><span class="line">		write.WriteString(v + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	write.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Initialization</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Please input the correct string (more than 2 characters) :&quot;</span>)</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	weights := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		<span class="keyword">if</span> v == <span class="string">&#x27;\r&#x27;</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		weights[v]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> weights &#123;</span><br><span class="line">		newNode := Constructor(<span class="keyword">byte</span>(i), v)</span><br><span class="line">		Nodes = <span class="built_in">append</span>(Nodes, newNode)</span><br><span class="line">	&#125;</span><br><span class="line">	NodesSort()</span><br><span class="line">	getHuffman()</span><br><span class="line">	SavehfmTree()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Initialization()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//hfmTree.txt</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">u</span><br><span class="line">nil</span><br><span class="line">nil</span><br><span class="line">i</span><br><span class="line">nil</span><br><span class="line">nil</span><br><span class="line">3</span><br><span class="line">b</span><br><span class="line">nil</span><br><span class="line">nil</span><br><span class="line">a</span><br><span class="line">nil</span><br><span class="line">nil</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>Encoding</h1>
<p>个人认为，应该用文件中的字符频率来生成哈夫曼树比较好，因为自己给定的字符串可能不会遍历到26个字母（或符号），这样在压缩文件时很明显是会error的</p>
<p>我选取了Alice梦游仙境的第一段来作为文件文本😋（其实本来想选莎士比亚的，但是没找到txt文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do.Once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it, &quot;and what is the use of a book,&quot; thought Alice, &quot;without pictures or conversations?&quot;So she was considering in her own mind (as well as she could, for the day made her feel very sleepy and stupid), whether the pleasure of making a daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly a White Rabbit with pink eyes ran close by her.There was nothing so very remarkable in that, nor did Alice think it so very much out of the way to hear the Rabbit say to itself, &quot;Oh dear! Oh dear! I shall be too late!&quot; But when the Rabbit actually took a watch out of its waistcoat-pocket and looked at it and then hurried on, Alice started to her feet, for it flashed across her mind that she had never before seen a rabbit with either a waistcoat-pocket, or a watch to take out of it, and, burning with curiosity, she ran across the field after it and was just in time to see it pop down a large rabbit-hole, under the hedge. In another moment, down went Alice after it! The rabbit-hole went straight on like a tunnel for some way and then dipped suddenly down, so suddenly that Alice had not a moment to think about stopping herself before she found herself falling down what seemed to be a very deep well.</span><br></pre></td></tr></table></figure>
<p>然后就是根据这一段文本建个哈夫曼树，同时将每个字符对应的序列作为文件写下来</p>
<p>这里为了方便是否应该整一个双射的结构体？比如字母a就和编码001形成双射，方便编码与解码的转换</p>
<p>因为是好几周前写的代码，用的都是全局变量+不带参数的函数，回头改又太麻烦就照着之前的改改…（顺便这几天学了匿名函数，可以不用再额外声明一个<code>Traverse</code>了</p>
<p>屎山</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encoding</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data, err := ioutil.ReadFile(<span class="string">&quot;E:/数据结构和算法/Week10/Alice.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	weights := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		weights[<span class="keyword">rune</span>(v)]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> weights &#123;</span><br><span class="line">		newNode := Constructor(<span class="keyword">byte</span>(i), v)</span><br><span class="line">		AliceNodes = <span class="built_in">append</span>(AliceNodes, newNode)</span><br><span class="line">	&#125;</span><br><span class="line">	AliceSort()</span><br><span class="line">	getAliceHuf()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据哈夫曼树生成字符串用于保存文件</span></span><br><span class="line">	<span class="keyword">var</span> trav <span class="function"><span class="keyword">func</span><span class="params">(root *Node, s <span class="keyword">string</span>)</span></span></span><br><span class="line">	str := <span class="string">&quot;&quot;</span></span><br><span class="line">	trav = <span class="function"><span class="keyword">func</span><span class="params">(root *Node, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> root.Val == <span class="number">0</span> &#123;</span><br><span class="line">			trav(root.Left, s+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">			trav(root.Right, s+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			newBij := Bijection&#123;</span><br><span class="line">				root.Val, s,</span><br><span class="line">			&#125;</span><br><span class="line">			AliceStore = <span class="built_in">append</span>(AliceStore, newBij)</span><br><span class="line">			trav(root.Left, s+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">			trav(root.Right, s+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	trav(AliceTree.Root, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建哈夫曼编码的文件</span></span><br><span class="line">	file, err := os.Create(<span class="string">&quot;HufCode.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Encoding create file err =&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	write := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> AliceStore &#123;</span><br><span class="line">		write.WriteString(<span class="keyword">string</span>(v.Char) + <span class="string">&quot; &quot;</span> + v.Str + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	write.Flush()</span><br><span class="line"></span><br><span class="line">	EncodeFile, err := os.Create(<span class="string">&quot;CodeFile.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Encode file create err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> EncodeFile.Close()</span><br><span class="line"></span><br><span class="line">	write = bufio.NewWriter(EncodeFile)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个byte -&gt; string的映射</span></span><br><span class="line">	x := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> AliceStore &#123;</span><br><span class="line">		x[v.Char] = v.Str</span><br><span class="line">	&#125;</span><br><span class="line">	write.Flush()</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		write.WriteString(x[v] + <span class="string">&quot; &quot;</span>)</span><br><span class="line">		write.Flush()</span><br><span class="line">	&#125;</span><br><span class="line">	write.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Decoding</h1>
<p>编码和解码其实都挺简单的</p>
<p>用结构体数组构造双射还是失败了，因为如果是结构体数组，还是得遍历一遍数组索引才能找到对应的key/value值，没有哈希表线程池这种东西查找方便…</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decoding</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data, err := ioutil.ReadFile(<span class="string">&quot;CodeFile.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Decoding read file err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建一个string -&gt; byte的映射</span></span><br><span class="line">	y := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">byte</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> AliceStore &#123;</span><br><span class="line">		y[v.Str] = v.Char</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Decodefile, err := os.Create(<span class="string">&quot;TextFile.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Decoding create file err =&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> Decodefile.Close()</span><br><span class="line"></span><br><span class="line">	writer := bufio.NewWriter(Decodefile)</span><br><span class="line">	s := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">if</span> v == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">			writer.WriteByte(y[s])</span><br><span class="line">			s = <span class="string">&quot;&quot;</span></span><br><span class="line">			writer.Flush()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s += <span class="keyword">string</span>(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是打印出来的编码文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10001011 01101 0111 101111 1111 00 111010 1010 11100 00 110100 1111 100001 0111 0101 0101 0111 0101 100001 00 1100 1001 00 100001 1111 1100 00 11101111 1111 11011 100000 00 1100 0111 11011 1111 10110 00 1001 100011 00 11100 0111 1100 1100 0111 0101 100001 00 110100 100000 00 0100 1111 11011 00 11100 0111 11100 1100 1111 11011 00 1001 0101 00 1100 0100 1111 00 110100 1010 0101 1110110 011001 00 1010 0101 10110 00 1001 100011 00 0100 1010 11101111 0111 0101 100001 00 0101 1001 1100 0100 0111 0101 100001 00 1100 1001 00 10110 1001 101110111 101110101 0101 101111 1111 00 1001 11011 00 1100 111010 0111 101111 1111 00 11100 0100 1111 00 0100 1010 10110 00 011000 1111 1111 011000 1111 10110 00 0111 0101 1100 1001 00 1100 0100 1111 00 110100 1001 1001 1110110 00 0100 1111 11011 00 11100 0111 11100 1100 1111 11011 00 111010 1010 11100 00 11011 1111 1010 10110 0111 0101 100001 011001 00 110100 110101 1100 00 0111 1100 00 0100 1010 10110 00 0101 1001 00 011000 0111 101111 1100 110101 11011 1111 11100 00 1001 11011 00 101111 1001 0101 11101111 1111 11011 11100 1010 1100 0111 1001 0101 11100 00 0111 0101 00 0111 1100 011001 00 10001010 1010 0101 10110 00 111010 0100 1010 1100 00 0111 11100 00 1100 0100 1111 00 110101 11100 1111 00 1001 100011 00 1010 00 110100 1001 1001 1110110 011001 10001010 00 1100 0100 1001 110101 100001 0100 1100 00 10001011 01101 0111 101111 1111 011001 00 10001010 111010 0111 1100 0100 1001 110101 1100 00 011000 0111 101111 1100 110101 11011 1111 11100 00 1001 11011 00 101111 1001 0101 11101111 1111 11011 11100 1010 1100 0111 1001 0101 11100 1000100000 10001010 1000100011 1001 00 11100 0100 1111 00 111010 1010 11100 00 101111 1001 0101 11100 0111 10110 1111 11011 0111 0101 100001 00 0111 0101 00 0100 1111 11011 00 1001 111010 0101 00 1011100 0111 0101 10110 00 1000100001 1010 11100 00 111010 1111 01101 01101 00 1010 11100 00 11100 0100 1111 00 101111 1001 110101 01101 10110 011001 00 100011 1001 11011 00 1100 0100 1111 00 10110 1010 100000 00 1011100 1010 10110 1111 00 0100 1111 11011 00 100011 1111 1111 01101 00 11101111 1111 11011 100000 00 11100 01101 1111 1111 011000 100000 00 1010 0101 10110 00 11100 1100 110101 011000 0111 10110 1011101100 011001 00 111010 0100 1111 1100 0100 1111 11011 00 1100 0100 1111 00 011000 01101 1111 1010 11100 110101 11011 1111 00 1001 100011 00 1011100 1010 1110110 0111 0101 100001 00 1010 00 10110 1010 0111 11100 100000 10001001 101111 0100 1010 0111 0101 00 111010 1001 110101 01101 10110 00 110100 1111 00 111010 1001 11011 1100 0100 00 1100 0100 1111 00 1100 11011 1001 110101 110100 01101 1111 00 1001 100011 00 100001 1111 1100 1100 0111 0101 100001 00 110101 011000 00 1010 0101 10110 00 011000 0111 101111 1110110 0111 0101 100001 00 1100 0100 1111 00 10110 1010 0111 11100 0111 1111 11100 011001 00 111010 0100 1111 0101 00 11100 110101 10110 10110 1111 0101 01101 100000 00 1010 00 11101110110 0100 0111 1100 1111 00 101110100 1010 110100 110100 0111 1100 00 111010 0111 1100 0100 00 011000 0111 0101 1110110 00 1111 100000 1111 11100 00 11011 1010 0101 00 101111 01101 1001 11100 1111 00 110100 100000 00 0100 1111 11011 101110111 1110111010 0100 1111 11011 1111 00 111010 1010 11100 00 0101 1001 1100 0100 0111 0101 100001 00 11100 1001 00 11101111 1111 11011 100000 00 11011 1111 1011100 1010 11011 1110110 1010 110100 01101 1111 00 0111 0101 00 1100 0100 1010 1100 011001 00 0101 1001 11011 00 10110 0111 10110 00 10001011 01101 0111 101111 1111 00 1100 0100 0111 0101 1110110 00 0111 1100 00 11100 1001 00 11101111 1111 11011 100000 00 1011100 110101 101111 0100 00 1001 110101 1100 00 1001 100011 00 1100 0100 1111 00 111010 1010 100000 00 1100 1001 00 0100 1111 1010 11011 00 1100 0100 1111 00 101110100 1010 110100 110100 0111 1100 00 11100 1010 100000 00 1100 1001 00 0111 1100 11100 1111 01101 100011 011001 00 10001010 101110101 0100 00 10110 1111 1010 11011 111011100 00 101110101 0100 00 10110 1111 1010 11011 111011100 00 1011101101 00 11100 0100 1010 01101 01101 00 110100 1111 00 1100 1001 1001 00 01101 1010 1100 1111 111011100 10001010 00 1000100010 110101 1100 00 111010 0100 1111 0101 00 1100 0100 1111 00 101110100 1010 110100 110100 0111 1100 00 1010 101111 1100 110101 1010 01101 01101 100000 00 1100 1001 1001 1110110 00 1010 00 111010 1010 1100 101111 0100 00 1001 110101 1100 00 1001 100011 00 0111 1100 11100 00 111010 1010 0111 11100 1100 101111 1001 1010 1100 10001001 011000 1001 101111 1110110 1111 1100 00 1010 0101 10110 00 01101 1001 1001 1110110 1111 10110 00 1010 1100 00 0111 1100 00 1010 0101 10110 00 1100 0100 1111 0101 00 0100 110101 11011 11011 0111 1111 10110 00 1001 0101 011001 00 10001011 01101 0111 101111 1111 00 11100 1100 1010 11011 1100 1111 10110 00 1100 1001 00 0100 1111 11011 00 100011 1111 1111 1100 011001 00 100011 1001 11011 00 0111 1100 00 100011 01101 1010 11100 0100 1111 10110 00 1010 101111 11011 1001 11100 11100 00 0100 1111 11011 00 1011100 0111 0101 10110 00 1100 0100 1010 1100 00 11100 0100 1111 00 0100 1010 10110 00 0101 1111 11101111 1111 11011 00 110100 1111 100011 1001 11011 1111 00 11100 1111 1111 0101 00 1010 00 11011 1010 110100 110100 0111 1100 00 111010 0111 1100 0100 00 1111 0111 1100 0100 1111 11011 00 1010 00 111010 1010 0111 11100 1100 101111 1001 1010 1100 10001001 011000 1001 101111 1110110 1111 1100 011001 00 1001 11011 00 1010 00 111010 1010 1100 101111 0100 00 1100 1001 00 1100 1010 1110110 1111 00 1001 110101 1100 00 1001 100011 00 0111 1100 011001 00 1010 0101 10110 011001 00 110100 110101 11011 0101 0111 0101 100001 00 111010 0111 1100 0100 00 101111 110101 11011 0111 1001 11100 0111 1100 100000 011001 00 11100 0100 1111 00 11011 1010 0101 00 1010 101111 11011 1001 11100 11100 00 1100 0100 1111 00 100011 0111 1111 01101 10110 00 1010 100011 1100 1111 11011 00 0111 1100 00 1010 0101 10110 00 111010 1010 11100 00 11101110111 110101 11100 1100 00 0111 0101 00 1100 0111 1011100 1111 00 1100 1001 00 11100 1111 1111 00 0111 1100 00 011000 1001 011000 00 10110 1001 111010 0101 00 1010 00 01101 1010 11011 100001 1111 00 11011 1010 110100 110100 0111 1100 10001001 0100 1001 01101 1111 011001 00 110101 0101 10110 1111 11011 00 1100 0100 1111 00 0100 1111 10110 100001 1111 101110111 00 1011101101 0101 00 1010 0101 1001 1100 0100 1111 11011 00 1011100 1001 1011100 1111 0101 1100 011001 00 10110 1001 111010 0101 00 111010 1111 0101 1100 00 10001011 01101 0111 101111 1111 00 1010 100011 1100 1111 11011 00 0111 1100 111011100 00 1110111010 0100 1111 00 11011 1010 110100 110100 0111 1100 10001001 0100 1001 01101 1111 00 111010 1111 0101 1100 00 11100 1100 11011 1010 0111 100001 0100 1100 00 1001 0101 00 01101 0111 1110110 1111 00 1010 00 1100 110101 0101 0101 1111 01101 00 100011 1001 11011 00 11100 1001 1011100 1111 00 111010 1010 100000 00 1010 0101 10110 00 1100 0100 1111 0101 00 10110 0111 011000 011000 1111 10110 00 11100 110101 10110 10110 1111 0101 01101 100000 00 10110 1001 111010 0101 011001 00 11100 1001 00 11100 110101 10110 10110 1111 0101 01101 100000 00 1100 0100 1010 1100 00 10001011 01101 0111 101111 1111 00 0100 1010 10110 00 0101 1001 1100 00 1010 00 1011100 1001 1011100 1111 0101 1100 00 1100 1001 00 1100 0100 0111 0101 1110110 00 1010 110100 1001 110101 1100 00 11100 1100 1001 011000 011000 0111 0101 100001 00 0100 1111 11011 11100 1111 01101 100011 00 110100 1111 100011 1001 11011 1111 00 11100 0100 1111 00 100011 1001 110101 0101 10110 00 0100 1111 11011 11100 1111 01101 100011 00 100011 1010 01101 01101 0111 0101 100001 00 10110 1001 111010 0101 00 111010 0100 1010 1100 00 11100 1111 1111 1011100 1111 10110 00 1100 1001 00 110100 1111 00 1010 00 11101111 1111 11011 100000 00 10110 1111 1111 011000 00 111010 1111 01101 01101 101110111 </span><br></pre></td></tr></table></figure>
<h1>Print</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data, err := ioutil.ReadFile(<span class="string">&quot;CodeFile.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Print read file err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里防止引用类型出错和出现Go专属的切片容量bug，所以使用一个copy</span></span><br><span class="line">	fileCopy := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(data))</span><br><span class="line">	<span class="built_in">copy</span>(fileCopy, data)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; i%<span class="number">50</span> == <span class="number">0</span> &#123;</span><br><span class="line">			fileCopy = <span class="built_in">append</span>(fileCopy[:i], <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;<span class="string">&#x27;\n&#x27;</span>&#125;, fileCopy[i+<span class="number">1</span>:]...)...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	CodePrinFile, err := os.Create(<span class="string">&quot;CodePrin.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;CodePrin file create err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> CodePrinFile.Close()</span><br><span class="line">    </span><br><span class="line">	writer := bufio.NewWriter(CodePrinFile)</span><br><span class="line">	writer.WriteString(<span class="keyword">string</span>(fileCopy))</span><br><span class="line">	writer.Flush()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> fileCopy &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%c&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10001011 01101 0111 101111 1111 00 111010 1010 110</span><br><span class="line">1 00 110100 1111 100001 0111 0101 0101 0111 0101 </span><br><span class="line">00001 00 1100 1001 00 100001 1111 1100 00 1110111</span><br><span class="line"> 1111 11100 011001 00 1100 0111 11100 1111 10110 </span><br><span class="line">0 1001 100011 00 11011 0111 1100 1100 0111 0101 1</span><br><span class="line">0001 00 110100 011001 00 0100 1111 11100 00 11011</span><br><span class="line">0111 11011 1100 1111 11100 00 1001 0101 00 1100 0</span><br><span class="line">00 1111 00 110100 1010 0101 1110110 100000 00 101</span><br><span class="line"> 0101 10110 00 1001 100011 00 0100 1010 11101111 </span><br><span class="line">111 0101 100001 00 0101 1001 1100 0100 0111 0101 </span><br><span class="line">00001 00 1100 1001 00 10110 1001 111011100 101110</span><br><span class="line">01 0101 101111 1111 00 1001 11100 00 1100 111010 </span><br><span class="line">111 101111 1111 00 11011 0100 1111 00 0100 1010 1</span><br><span class="line">110 00 011000 1111 1111 011000 1111 10110 00 0111</span><br><span class="line">0101 1100 1001 00 1100 0100 1111 00 110100 1001 1</span><br><span class="line">01 1110110 00 0100 1111 11100 00 11011 0111 11011</span><br><span class="line">1100 1111 11100 00 111010 1010 11011 00 11100 111</span><br><span class="line"> 1010 10110 0111 0101 100001 100000 00 110100 110</span><br><span class="line">01 1100 00 0111 1100 00 0100 1010 10110 00 0101 1</span><br><span class="line">01 00 011000 0111 101111 1100 110101 11100 1111 1</span><br><span class="line">011 00 1001 11100 00 101111 1001 0101 11101111 11</span><br><span class="line">1 11100 11011 1010 1100 0111 1001 0101 11011 00 0</span><br><span class="line">11 0101 00 0111 1100 100000 00 10001010 1010 0101</span><br><span class="line">10110 00 111010 0100 1010 1100 00 0111 11011 00 1</span><br><span class="line">00 0100 1111 00 110101 11011 1111 00 1001 100011 </span><br><span class="line">0 1010 00 110100 1001 1001 1110110 100000 1000101</span><br><span class="line"> 00 1100 0100 1001 110101 100001 0100 1100 00 100</span><br><span class="line">1011 01101 0111 101111 1111 100000 00 10001010 11</span><br><span class="line">010 0111 1100 0100 1001 110101 1100 00 011000 011</span><br><span class="line"> 101111 1100 110101 11100 1111 11011 00 1001 1110</span><br><span class="line"> 00 101111 1001 0101 11101111 1111 11100 11011 10</span><br><span class="line">0 1100 0111 1001 0101 11011 11101110110 10001010 </span><br><span class="line">000100000 1001 00 11011 0100 1111 00 111010 1010 </span><br><span class="line">1011 00 101111 1001 0101 11011 0111 10110 1111 11</span><br><span class="line">00 0111 0101 100001 00 0111 0101 00 0100 1111 111</span><br><span class="line">0 00 1001 111010 0101 00 1011100 0111 0101 10110 </span><br><span class="line">0 1000100010 1010 11011 00 111010 1111 01101 0110</span><br><span class="line"> 00 1010 11011 00 11011 0100 1111 00 101111 1001 </span><br><span class="line">10101 01101 10110 100000 00 100011 1001 11100 00 </span><br><span class="line">100 0100 1111 00 10110 1010 011001 00 1011100 101</span><br><span class="line"> 10110 1111 00 0100 1111 11100 00 100011 1111 111</span><br><span class="line"> 01101 00 11101111 1111 11100 011001 00 11011 011</span><br><span class="line">1 1111 1111 011000 011001 00 1010 0101 10110 00 1</span><br><span class="line">011 1100 110101 011000 0111 10110 11101110111 100</span><br><span class="line">00 00 111010 0100 1111 1100 0100 1111 11100 00 11</span><br><span class="line">0 0100 1111 00 011000 01101 1111 1010 11011 11010</span><br><span class="line"> 11100 1111 00 1001 100011 00 1011100 1010 111011</span><br><span class="line"> 0111 0101 100001 00 1010 00 10110 1010 0111 1101</span><br><span class="line"> 011001 10001001 101111 0100 1010 0111 0101 00 11</span><br><span class="line">010 1001 110101 01101 10110 00 110100 1111 00 111</span><br><span class="line">10 1001 11100 1100 0100 00 1100 0100 1111 00 1100</span><br><span class="line">11100 1001 110101 110100 01101 1111 00 1001 10001</span><br><span class="line"> 00 100001 1111 1100 1100 0111 0101 100001 00 110</span><br><span class="line">01 011000 00 1010 0101 10110 00 011000 0111 10111</span><br><span class="line"> 1110110 0111 0101 100001 00 1100 0100 1111 00 10</span><br><span class="line">10 1010 0111 11011 0111 1111 11011 100000 00 1110</span><br><span class="line">0 0100 1111 0101 00 11011 110101 10110 10110 1111</span><br><span class="line">0101 01101 011001 00 1010 00 1000100001 0100 0111</span><br><span class="line">1100 1111 00 101110100 1010 110100 110100 0111 11</span><br><span class="line">0 00 111010 0111 1100 0100 00 011000 0111 0101 11</span><br><span class="line">0110 00 1111 011001 1111 11011 00 11100 1010 0101</span><br><span class="line">00 101111 01101 1001 11011 1111 00 110100 011001 </span><br><span class="line">0 0100 1111 11100 111011100 1011101101 0100 1111 </span><br><span class="line">1100 1111 00 111010 1010 11011 00 0101 1001 1100 </span><br><span class="line">100 0111 0101 100001 00 11011 1001 00 11101111 11</span><br><span class="line">1 11100 011001 00 11100 1111 1011100 1010 11100 1</span><br><span class="line">10110 1010 110100 01101 1111 00 0111 0101 00 1100</span><br><span class="line">0100 1010 1100 100000 00 0101 1001 11100 00 10110</span><br><span class="line">0111 10110 00 10001011 01101 0111 101111 1111 00 </span><br><span class="line">100 0100 0111 0101 1110110 00 0111 1100 00 11011 </span><br><span class="line">001 00 11101111 1111 11100 011001 00 1011100 1101</span><br><span class="line">1 101111 0100 00 1001 110101 1100 00 1001 100011 </span><br><span class="line">0 1100 0100 1111 00 111010 1010 011001 00 1100 10</span><br><span class="line">1 00 0100 1111 1010 11100 00 1100 0100 1111 00 10</span><br><span class="line">110100 1010 110100 110100 0111 1100 00 11011 1010</span><br><span class="line">011001 00 1100 1001 00 0111 1100 11011 1111 01101</span><br><span class="line">100011 100000 00 10001010 101110101 0100 00 10110</span><br><span class="line">1111 1010 11100 101110111 00 101110101 0100 00 10</span><br><span class="line">10 1111 1010 11100 101110111 00 1110111010 00 110</span><br><span class="line">1 0100 1010 01101 01101 00 110100 1111 00 1100 10</span><br><span class="line">1 1001 00 01101 1010 1100 1111 101110111 10001010</span><br><span class="line">00 1000100011 110101 1100 00 111010 0100 1111 010</span><br><span class="line"> 00 1100 0100 1111 00 101110100 1010 110100 11010</span><br><span class="line"> 0111 1100 00 1010 101111 1100 110101 1010 01101 </span><br><span class="line">1101 011001 00 1100 1001 1001 1110110 00 1010 00 </span><br><span class="line">11010 1010 1100 101111 0100 00 1001 110101 1100 0</span><br><span class="line"> 1001 100011 00 0111 1100 11011 00 111010 1010 01</span><br><span class="line">1 11011 1100 101111 1001 1010 1100 10001001 01100</span><br><span class="line"> 1001 101111 1110110 1111 1100 00 1010 0101 10110</span><br><span class="line">00 01101 1001 1001 1110110 1111 10110 00 1010 110</span><br><span class="line"> 00 0111 1100 00 1010 0101 10110 00 1100 0100 111</span><br><span class="line"> 0101 00 0100 110101 11100 11100 0111 1111 10110 </span><br><span class="line">0 1001 0101 100000 00 10001011 01101 0111 101111 </span><br><span class="line">111 00 11011 1100 1010 11100 1100 1111 10110 00 1</span><br><span class="line">00 1001 00 0100 1111 11100 00 100011 1111 1111 11</span><br><span class="line">0 100000 00 100011 1001 11100 00 0111 1100 00 100</span><br><span class="line">11 01101 1010 11011 0100 1111 10110 00 1010 10111</span><br><span class="line"> 11100 1001 11011 11011 00 0100 1111 11100 00 101</span><br><span class="line">100 0111 0101 10110 00 1100 0100 1010 1100 00 110</span><br><span class="line">1 0100 1111 00 0100 1010 10110 00 0101 1111 11101</span><br><span class="line">11 1111 11100 00 110100 1111 100011 1001 11100 11</span><br><span class="line">1 00 11011 1111 1111 0101 00 1010 00 11100 1010 1</span><br><span class="line">0100 110100 0111 1100 00 111010 0111 1100 0100 00</span><br><span class="line">1111 0111 1100 0100 1111 11100 00 1010 00 111010 </span><br><span class="line">010 0111 11011 1100 101111 1001 1010 1100 1000100</span><br><span class="line"> 011000 1001 101111 1110110 1111 1100 100000 00 1</span><br><span class="line">01 11100 00 1010 00 111010 1010 1100 101111 0100 </span><br><span class="line">0 1100 1001 00 1100 1010 1110110 1111 00 1001 110</span><br><span class="line">01 1100 00 1001 100011 00 0111 1100 100000 00 101</span><br><span class="line"> 0101 10110 100000 00 110100 110101 11100 0101 01</span><br><span class="line">1 0101 100001 00 111010 0111 1100 0100 00 101111 </span><br><span class="line">10101 11100 0111 1001 11011 0111 1100 011001 1000</span><br><span class="line">0 00 11011 0100 1111 00 11100 1010 0101 00 1010 1</span><br><span class="line">1111 11100 1001 11011 11011 00 1100 0100 1111 00 </span><br><span class="line">00011 0111 1111 01101 10110 00 1010 100011 1100 1</span><br><span class="line">11 11100 00 0111 1100 00 1010 0101 10110 00 11101</span><br><span class="line"> 1010 11011 00 1011101100 110101 11011 1100 00 01</span><br><span class="line">1 0101 00 1100 0111 1011100 1111 00 1100 1001 00 </span><br><span class="line">1011 1111 1111 00 0111 1100 00 011000 1001 011000</span><br><span class="line">00 10110 1001 111010 0101 00 1010 00 01101 1010 1</span><br><span class="line">100 100001 1111 00 11100 1010 110100 110100 0111 </span><br><span class="line">100 10001001 0100 1001 01101 1111 100000 00 11010</span><br><span class="line"> 0101 10110 1111 11100 00 1100 0100 1111 00 0100 </span><br><span class="line">111 10110 100001 1111 111011100 00 1110111010 010</span><br><span class="line"> 00 1010 0101 1001 1100 0100 1111 11100 00 101110</span><br><span class="line"> 1001 1011100 1111 0101 1100 100000 00 10110 1001</span><br><span class="line">111010 0101 00 111010 1111 0101 1100 00 10001011 </span><br><span class="line">1101 0111 101111 1111 00 1010 100011 1100 1111 11</span><br><span class="line">00 00 0111 1100 101110111 00 1011101101 0100 1111</span><br><span class="line">00 11100 1010 110100 110100 0111 1100 10001001 01</span><br><span class="line">0 1001 01101 1111 00 111010 1111 0101 1100 00 110</span><br><span class="line">1 1100 11100 1010 0111 100001 0100 1100 00 1001 0</span><br><span class="line">01 00 01101 0111 1110110 1111 00 1010 00 1100 110</span><br><span class="line">01 0101 0101 1111 01101 00 100011 1001 11100 00 1</span><br><span class="line">011 1001 1011100 1111 00 111010 1010 011001 00 10</span><br><span class="line">0 0101 10110 00 1100 0100 1111 0101 00 10110 0111</span><br><span class="line">011000 011000 1111 10110 00 11011 110101 10110 10</span><br><span class="line">10 1111 0101 01101 011001 00 10110 1001 111010 01</span><br><span class="line">1 100000 00 11011 1001 00 11011 110101 10110 1011</span><br><span class="line"> 1111 0101 01101 011001 00 1100 0100 1010 1100 00</span><br><span class="line">10001011 01101 0111 101111 1111 00 0100 1010 1011</span><br><span class="line"> 00 0101 1001 1100 00 1010 00 1011100 1001 101110</span><br><span class="line"> 1111 0101 1100 00 1100 1001 00 1100 0100 0111 01</span><br><span class="line">1 1110110 00 1010 110100 1001 110101 1100 00 1101</span><br><span class="line"> 1100 1001 011000 011000 0111 0101 100001 00 0100</span><br><span class="line">1111 11100 11011 1111 01101 100011 00 110100 1111</span><br><span class="line">100011 1001 11100 1111 00 11011 0100 1111 00 1000</span><br><span class="line">1 1001 110101 0101 10110 00 0100 1111 11100 11011</span><br><span class="line">1111 01101 100011 00 100011 1010 01101 01101 0111</span><br><span class="line">0101 100001 00 10110 1001 111010 0101 00 111010 0</span><br><span class="line">00 1010 1100 00 11011 1111 1111 1011100 1111 1011</span><br><span class="line"> 00 1100 1001 00 110100 1111 00 1010 00 11101111 </span><br><span class="line">111 11100 011001 00 10110 1111 1111 011000 00 111</span><br><span class="line">10 1111 01101 01101 111011100 </span><br></pre></td></tr></table></figure>
<h1>Tree printing</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TreePrinting</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> PrintHelp <span class="function"><span class="keyword">func</span><span class="params">(root *Node, s <span class="keyword">string</span>)</span></span></span><br><span class="line">	PrintHelp = <span class="function"><span class="keyword">func</span><span class="params">(root *Node, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		s += <span class="string">&quot;\t&quot;</span></span><br><span class="line">		PrintHelp(root.Right, s)</span><br><span class="line">		<span class="keyword">if</span> root.Val == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(s+<span class="string">&quot; %d\n&quot;</span>, root.Weight)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(s+<span class="string">&quot;%c%d\n&quot;</span>, root.Val, root.Weight)</span><br><span class="line">		&#125;</span><br><span class="line">		PrintHelp(root.Left, s)</span><br><span class="line">	&#125;</span><br><span class="line">	PrintHelp(AliceTree.Root, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字母太多打下来比较难看…</p>
<p>截取一小部分解释一下…</p>
<p>如果是权值点，就只打印权值，如果是字母，就以字母+权值的格式打印</p>
<p>267是权值，由140的e和127的权值组成，127旁边根据相邻程度可以看到是r63和64的权值……这样看好一点</p>
<h1>整体代码</h1>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val    <span class="keyword">byte</span></span><br><span class="line">	Weight <span class="keyword">int</span></span><br><span class="line">	Left   *Node</span><br><span class="line">	Right  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuffmanTree <span class="keyword">struct</span> &#123;</span><br><span class="line">	Root *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(v <span class="keyword">byte</span>, w <span class="keyword">int</span>)</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Node&#123;</span><br><span class="line">		v, w, <span class="literal">nil</span>, <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Nodes []Node</span><br><span class="line"><span class="keyword">var</span> AliceNodes []Node</span><br><span class="line"><span class="keyword">var</span> Tree = HuffmanTree&#123;Root: &amp;Node&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> AliceTree = HuffmanTree&#123;Root: &amp;Node&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对结构体的排序重载</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NodesSort</span><span class="params">()</span></span> &#123;</span><br><span class="line">	less := <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Nodes[i].Weight &lt; Nodes[j].Weight</span><br><span class="line">	&#125;</span><br><span class="line">	sort.SliceStable(Nodes, less)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AliceSort</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sort.SliceStable(AliceNodes, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> AliceNodes[i].Weight &lt; AliceNodes[j].Weight</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈夫曼树排序与生成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHuffman</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(Nodes) != <span class="number">2</span> &#123;</span><br><span class="line">		newNode := Constructor(<span class="number">0</span>, Nodes[<span class="number">0</span>].Weight+Nodes[<span class="number">1</span>].Weight)</span><br><span class="line">		newNode.Left = &amp;Nodes[<span class="number">0</span>]</span><br><span class="line">		newNode.Right = &amp;Nodes[<span class="number">1</span>]</span><br><span class="line">		Nodes = <span class="built_in">append</span>(Nodes, newNode)</span><br><span class="line">		Nodes = Nodes[<span class="number">2</span>:]</span><br><span class="line">		NodesSort()</span><br><span class="line">	&#125;</span><br><span class="line">	NodesSort()</span><br><span class="line">	Tree.Root.Weight = Nodes[<span class="number">0</span>].Weight + Nodes[<span class="number">1</span>].Weight</span><br><span class="line">	Tree.Root.Left = &amp;Nodes[<span class="number">0</span>]</span><br><span class="line">	Tree.Root.Right = &amp;Nodes[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAliceHuf</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(AliceNodes) != <span class="number">2</span> &#123;</span><br><span class="line">		newNode := Constructor(<span class="number">0</span>, AliceNodes[<span class="number">0</span>].Weight+AliceNodes[<span class="number">1</span>].Weight)</span><br><span class="line">		newNode.Left = &amp;AliceNodes[<span class="number">0</span>]</span><br><span class="line">		newNode.Right = &amp;AliceNodes[<span class="number">1</span>]</span><br><span class="line">		AliceNodes = <span class="built_in">append</span>(AliceNodes, newNode)</span><br><span class="line">		AliceNodes = AliceNodes[<span class="number">2</span>:]</span><br><span class="line">		AliceSort()</span><br><span class="line">	&#125;</span><br><span class="line">	AliceSort()</span><br><span class="line">	AliceTree.Root.Weight = AliceNodes[<span class="number">0</span>].Weight + AliceNodes[<span class="number">1</span>].Weight</span><br><span class="line">	AliceTree.Root.Left = &amp;AliceNodes[<span class="number">0</span>]</span><br><span class="line">	AliceTree.Root.Right = &amp;AliceNodes[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> store = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bijection <span class="keyword">struct</span> &#123;</span><br><span class="line">	Char <span class="keyword">byte</span>   <span class="comment">//双射的字符</span></span><br><span class="line">	Str  <span class="keyword">string</span> <span class="comment">//双射的字符对应的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AliceStore = <span class="built_in">make</span>([]Bijection, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历生成哈夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Traverse</span><span class="params">(root *Node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		store = <span class="built_in">append</span>(store, <span class="string">&quot;nil&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.Val == <span class="number">0</span> &#123;</span><br><span class="line">		store = <span class="built_in">append</span>(store, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, root.Weight))</span><br><span class="line">		Traverse(root.Left)</span><br><span class="line">		Traverse(root.Right)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		store = <span class="built_in">append</span>(store, <span class="keyword">string</span>(root.Val))</span><br><span class="line">		Traverse(root.Left)</span><br><span class="line">		Traverse(root.Right)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将哈夫曼树的内容保存在filename文件中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SavehfmTree</span><span class="params">(filename <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.Create(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Create htfTree err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	write := bufio.NewWriter(file)</span><br><span class="line">	Traverse(Tree.Root)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> store &#123;</span><br><span class="line">		write.WriteString(v + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	write.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Initialization</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Please input the correct string (more than 2 characters) :&quot;</span>)</span><br><span class="line">	reader := bufio.NewReader(os.Stdin)</span><br><span class="line">	input, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	weights := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> input &#123;</span><br><span class="line">		<span class="keyword">if</span> v == <span class="string">&#x27;\r&#x27;</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		weights[v]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> weights &#123;</span><br><span class="line">		newNode := Constructor(<span class="keyword">byte</span>(i), v)</span><br><span class="line">		Nodes = <span class="built_in">append</span>(Nodes, newNode)</span><br><span class="line">	&#125;</span><br><span class="line">	NodesSort()</span><br><span class="line">	getHuffman()</span><br><span class="line">	SavehfmTree(<span class="string">&quot;hfmTree.txt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowMenu</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Please input the correct character to choose which function you would like to use:&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;I:初始化Initialization&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;E:编码Encoding&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;D:译码Decoding&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;P:打印代码文件Print&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;T:打印哈夫曼树Tree printing&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;B:退出本程序循环Break&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encoding</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data, err := ioutil.ReadFile(<span class="string">&quot;E:/数据结构和算法/Week10/Alice.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	weights := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		weights[<span class="keyword">rune</span>(v)]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> weights &#123;</span><br><span class="line">		newNode := Constructor(<span class="keyword">byte</span>(i), v)</span><br><span class="line">		AliceNodes = <span class="built_in">append</span>(AliceNodes, newNode)</span><br><span class="line">	&#125;</span><br><span class="line">	AliceSort()</span><br><span class="line">	getAliceHuf()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据哈夫曼树生成字符串用于保存文件</span></span><br><span class="line">	<span class="keyword">var</span> trav <span class="function"><span class="keyword">func</span><span class="params">(root *Node, s <span class="keyword">string</span>)</span></span></span><br><span class="line">	str := <span class="string">&quot;&quot;</span></span><br><span class="line">	trav = <span class="function"><span class="keyword">func</span><span class="params">(root *Node, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> root.Val == <span class="number">0</span> &#123;</span><br><span class="line">			trav(root.Left, s+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">			trav(root.Right, s+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			newBij := Bijection&#123;</span><br><span class="line">				root.Val, s,</span><br><span class="line">			&#125;</span><br><span class="line">			AliceStore = <span class="built_in">append</span>(AliceStore, newBij)</span><br><span class="line">			trav(root.Left, s+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">			trav(root.Right, s+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	trav(AliceTree.Root, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建哈夫曼编码的文件</span></span><br><span class="line">	file, err := os.Create(<span class="string">&quot;HufCode.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Encoding create file err =&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	write := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> AliceStore &#123;</span><br><span class="line">		write.WriteString(<span class="keyword">string</span>(v.Char) + <span class="string">&quot; &quot;</span> + v.Str + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	write.Flush()</span><br><span class="line"></span><br><span class="line">	EncodeFile, err := os.Create(<span class="string">&quot;CodeFile.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Encode file create err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> EncodeFile.Close()</span><br><span class="line"></span><br><span class="line">	write = bufio.NewWriter(EncodeFile)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个byte -&gt; string的映射</span></span><br><span class="line">	x := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> AliceStore &#123;</span><br><span class="line">		x[v.Char] = v.Str</span><br><span class="line">	&#125;</span><br><span class="line">	write.Flush()</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		write.WriteString(x[v] + <span class="string">&quot; &quot;</span>)</span><br><span class="line">		write.Flush()</span><br><span class="line">	&#125;</span><br><span class="line">	write.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decoding</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data, err := ioutil.ReadFile(<span class="string">&quot;CodeFile.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Decoding read file err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建一个string -&gt; byte的映射</span></span><br><span class="line">	y := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">byte</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> AliceStore &#123;</span><br><span class="line">		y[v.Str] = v.Char</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Decodefile, err := os.Create(<span class="string">&quot;TextFile.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Decoding create file err =&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> Decodefile.Close()</span><br><span class="line"></span><br><span class="line">	writer := bufio.NewWriter(Decodefile)</span><br><span class="line">	s := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">if</span> v == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">			writer.WriteByte(y[s])</span><br><span class="line">			s = <span class="string">&quot;&quot;</span></span><br><span class="line">			writer.Flush()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s += <span class="keyword">string</span>(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data, err := ioutil.ReadFile(<span class="string">&quot;CodeFile.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Print read file err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fileCopy := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(data))</span><br><span class="line">	<span class="built_in">copy</span>(fileCopy, data)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> data &#123;</span><br><span class="line">		<span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; i%<span class="number">50</span> == <span class="number">0</span> &#123;</span><br><span class="line">			fileCopy = <span class="built_in">append</span>(fileCopy[:i], <span class="built_in">append</span>([]<span class="keyword">byte</span>&#123;<span class="string">&#x27;\n&#x27;</span>&#125;, fileCopy[i+<span class="number">1</span>:]...)...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	CodePrinFile, err := os.Create(<span class="string">&quot;CodePrin.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;CodePrin file create err =&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> CodePrinFile.Close()</span><br><span class="line">	writer := bufio.NewWriter(CodePrinFile)</span><br><span class="line">	writer.WriteString(<span class="keyword">string</span>(fileCopy))</span><br><span class="line">	writer.Flush()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> fileCopy &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%c&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TreePrinting</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> PrintHelp <span class="function"><span class="keyword">func</span><span class="params">(root *Node, s <span class="keyword">string</span>)</span></span></span><br><span class="line">	PrintHelp = <span class="function"><span class="keyword">func</span><span class="params">(root *Node, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		s += <span class="string">&quot;\t&quot;</span></span><br><span class="line">		PrintHelp(root.Right, s)</span><br><span class="line">		<span class="keyword">if</span> root.Val == <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Printf(s+<span class="string">&quot; %d\n&quot;</span>, root.Weight)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(s+<span class="string">&quot;%c%d\n&quot;</span>, root.Val, root.Weight)</span><br><span class="line">		&#125;</span><br><span class="line">		PrintHelp(root.Left, s)</span><br><span class="line">	&#125;</span><br><span class="line">	PrintHelp(AliceTree.Root, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> flag &#123;</span><br><span class="line">		ShowMenu()</span><br><span class="line">		reader := bufio.NewReader(os.Stdin)</span><br><span class="line">		c, err := reader.ReadByte()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;read c err =&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">switch</span> c &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">			Initialization()</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">			Encoding()</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">			Decoding()</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">			Print()</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">			TreePrinting()</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">			flag = <span class="literal">false</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>实验总结</h1>
<ol>
<li>老实说这是我整了go语言以来敲得最长的单个文件了…</li>
<li>整体不是特别难，在哈夫曼树创建完成之后就没有什么特别卡死人的地方了，主要是文件的创建读写操作会很烦，但是耐心搞搞就解决辣</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithms/">Algorithms</a></div><div class="post_share"><div class="social-share" data-image="/img/47.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/16/Fk-Final-Exam-2/"><img class="prev-cover" src="/img/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Fk Final Exam 2</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/03/2022-April/"><img class="next-cover" src="/img/33.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2022 April</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/31/2022%E8%B7%A8%E5%B9%B4%E5%A4%9C%E4%B8%8ELeetcode/" title="2022跨年夜与两数之和"><img class="cover" src="/img/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-31</div><div class="title">2022跨年夜与两数之和</div></div></a></div><div><a href="/2021/12/25/About-Linked-List/" title="About Linked List"><img class="cover" src="/img/18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-25</div><div class="title">About Linked List</div></div></a></div><div><a href="/2021/12/08/Discrete%20Mathematics%20Lab1/" title="Discrete Mathematics Lab1"><img class="cover" src="/img/3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-08</div><div class="title">Discrete Mathematics Lab1</div></div></a></div><div><a href="/2021/12/14/Discrete%20Mathematics%20Lab2/" title="Discrete Mathematics Lab2"><img class="cover" src="/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-14</div><div class="title">Discrete Mathematics Lab2</div></div></a></div><div><a href="/2021/12/21/Discrete-Mathematics-Lab3/" title="Discrete Mathematics Lab3"><img class="cover" src="/img/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-21</div><div class="title">Discrete Mathematics Lab3</div></div></a></div><div><a href="/2021/12/27/Discrete-Mathematics-Lab4/" title="Discrete Mathematics Lab4"><img class="cover" src="/img/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">Discrete Mathematics Lab4</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Target &amp; Content</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Requirement</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E8%BE%93%E5%85%A5%E4%B8%8E%E5%BE%97%E5%88%B0%E6%9D%83%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">标准化输入与得到权值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%9D%83%E5%80%BC%E5%BB%BA%E7%AB%8BHuffman-Tree"><span class="toc-number">3.2.</span> <span class="toc-text">通过权值建立Huffman Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">保存二叉树及写入文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">3.4.</span> <span class="toc-text">总览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Encoding</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Decoding</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Print</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Tree printing</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">整体代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">实验总结</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Koui</div><div class="footer_custom_text">And in case I don't see you, Good afternoon, Good evening, and Good night!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="canvas_nest" defer="defer" color="128,128,105" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>